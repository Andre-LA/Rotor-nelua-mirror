--[[
The storage module, it's a type constructor where you pass a type `T` and a non-zero positive
integer `size` value.

The result is a storage type capable of storing `size` entries of type `T`, always re-using
free slots as possible.

For example, if you use a storage capable of storing 3 entries and you push 3 entries on it,
and then removes the second entry, then a fourth entry can be pushed and it will use the second
slot, thus the generational index of this fourth entry will be a second generation of the second slot.
]]

-- Copyright (c) 2019-2022 AndrÃ© Luiz Alvares
-- SPDX-License-Identifier: MIT


local GenIdx = require 'rotor.gen_idx'

## local make_storage = generalize(function(T, size)
  ##[[
  static_assert(
    traits.is_number(size) and traits.is_integral(size) and size > 0,
    'size "%s" is not an positive whole number',
    size
  )
  ]]

  local SIZE <comptime> = #[size]#

  local T: type = #[T]#
  ## local nicknameT = string.format('storage(%s)', T.nickname)

  -- the storage type
  local storage <nickname(#[nicknameT]#)> = @record{
    entries: [SIZE]T,
    unavailables: [SIZE]boolean,
    generations: [SIZE]usize,
    next_idx: usize,
  }

  ## storage.value.is_container = true
  ## storage.value.is_storage = true
  ## storage.value.subtype = T

  local function find_next_available(storage: *storage, next_idx: usize): (boolean, usize)
    local idx = next_idx
    local found = false

    for i = 1, SIZE do
      if storage.unavailables[idx] then
        idx = (idx + 1) % SIZE
      else
        found = true
        break
      end
    end

    return found, idx
  end

  -- resets storage to a zeroed state
  function storage:clear()
    self.unavailables = {}
    self.generations = {}
    self.next_idx = 0
  end

  --[[
  Push a new entry on the storage on the next free slot, if no free slots are available,
  then a warning will be printed and this function will return `false`, a zeroed generational
  index and `nilptr`.

  Otherwise, the entry will be inserted on the found free slot and this function will return `true`,
  the generational index of the used slot and a reference to the inserted entry.
  ]]
  function storage:push(value: T): (boolean, GenIdx, *T)
    local available_found, available_idx = find_next_available(self, self.next_idx)

    if not available_found then
      warn(#[storage.value.nickname .. ": out of available entries, please increase the storage's size"]#)
      return false
    end

    self.next_idx = (available_idx + 1) % SIZE
    self.entries[available_idx] = value
    self.unavailables[available_idx] = true
    self.generations[available_idx] = self.generations[available_idx] + 1

    local gen_idx: GenIdx = { index = available_idx, generation = self.generations[available_idx] }
    return true, gen_idx, &self.entries[available_idx]
  end

  --[[
  Removes an entry associated with the generational index.

  If the entry is found, then the slot it's zeroed and the function returns `true`. Othewise
  it does nothing and returns `false`.
  ]]
  function storage:remove(idx: GenIdx): boolean
    if self.generations[idx.index] == idx.generation then
      self.entries[idx.index] = {}
      self.unavailables[idx.index] = false
      return true
    end
    return false
  end

  --[[
  Try to find the entry of the generational index.

  If found, then it returns `true` and a reference to the entry on the storage. Otherwise, it
  returns `false` and a `nilptr`.

  To void undefined behavior, always check or assert the returned boolean value.
  ]]
  function storage:mget(idx: GenIdx): (boolean, *T)
    if self.unavailables[idx.index] and self.generations[idx.index] == idx.generation then
      return true, &self.entries[idx.index]
    else
      return false, nilptr
    end
  end

  -- mnext method, used by `__mpairs` method, it finds the next entry to iterate.
  function storage:__mnext(ctrl_var: isize): (boolean, isize, *T)
    ctrl_var = ctrl_var + 1

    while ctrl_var < SIZE do
      if self.unavailables[ctrl_var] then
        return true, ctrl_var, &self.entries[ctrl_var]
      else
        ctrl_var = ctrl_var + 1
      end
    end

    return false, -1, nilptr
  end

  --[[
  Iterator for `mpairs`, this allows using `for in` using the `mpairs` iterator on
  the storage, it iterates only on the entries and skips unused slots.
  ]]
  function storage:__mpairs(): (auto, *storage, isize)
    return storage.__mnext, self, -1
  end

  ## return storage
## end)

-- Storage generic used to instantiate an storage type in the form of `component(T, size)`, where
-- `size` is the maximum number of entries.
local storage: type = #[make_storage]#
return storage
