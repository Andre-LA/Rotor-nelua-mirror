local GenIdx = require 'rotor.gen_idx'

## local make_storage = generalize(function(T, size)
  ##[[
  static_assert(
    traits.is_number(size) and traits.is_integral(size) and size > 0,
    'size "%s" is not an positive whole number',
    size
  )
  ]]

  local SIZE <comptime> = #[size]#

  local T: type = #[T]#
  ## local nicknameT = string.format('storage(%s)', T.nickname)

  local storageT <nickname(#[nicknameT]#)> = @record{
    entries: [SIZE]T,
    unavailables: [SIZE]boolean,
    generations: [SIZE]usize,
    next_idx: usize,
  }

  ## storageT.value.is_container = true
  ## storageT.value.is_storage = true
  ## storageT.value.subtype = T

  local function find_next_available(storage: *storageT, next_idx: usize): (boolean, usize)
    local idx = next_idx
    local found = false

    for i = 1, SIZE do
      if storage.unavailables[idx] then
        idx = (idx + 1) % SIZE
      else
        found = true
        break
      end
    end

    return found, idx
  end

  function storageT:push(value: T): (boolean, GenIdx)
    local available_found, available_idx = find_next_available(self, self.next_idx)

    if not available_found then
      warn(#[storageT.value.nickname .. ": out of available entries, please increase the storage's size"]#)
      return false, (@GenIdx)()
    end

    self.next_idx = (available_idx + 1) % SIZE
    self.entries[available_idx] = value
    self.unavailables[available_idx] = true
    self.generations[available_idx] = self.generations[available_idx] + 1

    local gen_idx: GenIdx = { index = available_idx, generation = self.generations[available_idx] }
    return true, gen_idx
  end

  function storageT:remove(idx: GenIdx)
    if self.generations[idx.index] == idx.generation then
      self.entries[idx.index] = {}
      self.unavailables[idx.index] = false
    end
  end

  function storageT:mget(idx: GenIdx): (boolean, *T)
    if self.unavailables[idx.index] and self.generations[idx.index] == idx.generation then
      return true, &self.entries[idx.index]
    else
      return false, nilptr
    end
  end

  function storageT:__mnext(ctrl_var: isize): (boolean, isize, *T)
    ctrl_var = ctrl_var + 1

    while ctrl_var < SIZE do
      if self.unavailables[ctrl_var] then
        return true, ctrl_var, &self.entries[ctrl_var]
      else
        ctrl_var = ctrl_var + 1
      end
    end

    return false, -1, nilptr
  end

  function storageT:__mpairs(): (auto, *storageT, isize)
    return storageT.__mnext, self, -1
  end

  ## return storageT
## end)

local storage: type = #[make_storage]#
return storage
